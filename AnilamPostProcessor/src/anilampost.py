'''
A script to convert GCode to Anilam conversational format.

Copyright (C) 2010 Scott Hasse <scott.hasse@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.


Developed by Scott Hasse for use at http://sector67.org

More details on the gcode specification can be found here:

http://www.linuxcnc.org/handbook/gcode/g-code.html

The conversational format can be found partially described at:

http://www.anilam.com/Uploads/File/Training%20Presentation%20PDF%20Files/3000M_Training_2.pdf

In general since the code generated by this script will ultimately be used to move
a machine, the goal of this script is to accurately translate programs, and
to fail fast and accurately when that cannot be done.  As a result, some of the 
implementation (most notably convert_to_conversational) probably appears to
be implemented in a fairly brittle manner.  This is for the most part intentional.
Each command and variation handled is explicit, and other unknown commands result
in an error.

It is expected this script will have a few primary uses:

1) For converting programs that are larger than the Anilam 1100 can handle.  These
programs will then subsequently be drip fed to the mill.
2) To correctly translate gcode programs that use arcs with IJK coordinates
specified incrementally.  Although incremental IJK specification is the default
in gcode, the Anilam-based translator expects the IJK to be absolute.  Although
this translator is incomplete, it is superior in that respect.
3) To avoid multiple round-trips to the mill with floppy disks.

TODO:
* The gcode verifier could be greatly improved.  However, since the translation
is done rather explicitly, it is hoped this will not introduce any risk to the
translation process.
* Translations for many Anilam functions that have gcode equivalents (peck drill, 
etc.) are not implemented
'''

import re
import getopt
import sys
from datetime import datetime

known_gcode_words = "FGIJKMNOPSXYZ"
log_level = 1
current_coords_mode = "ABS"
current_arc_coords_mode = "INC"

motion_modal_commands = set(["G0", "G1", "G2", "G3", "G80", "G81", "G82", "G83", "G84", "G85", "G86", "G87", "G88", "G89"])
plane_selection_modal_commands = set(["G17", "G18", "G19"])
distance_modal_commands = set(["G90", "G91"])
spindle_speed_modal_commands = set(["G93", "G94"])
units_modal_commands = set(["G20", "G21"])
cutter_diameter_compensation_modal_commands = set(["G40", "G41", "G42"])
tool_length_offset_modal_commands  = set(["G43", "G49"])
return_mode_in_canned_cycles_modal_commands = set(["G98", "G99"])
coordinate_system_selection_modal_commands = set(["G54", "G55", "G56", "G57", "G58", "G59", "G59.1", "G59.2", "G59.3"])


axis_clamping_modal_commands = set(["M26", "M27"]) 
stopping_modal_commands = set(["M0", "M1", "M2", "M30", "M60"])
tool_change_modal_commands  = set(["M6"])
spindle_turning_modal_commands  = set(["M3", "M4", "M5"])
coolant_modal_commands = set(["M7", "M8", "M9"])
feed_and_speed_override_bypass_modal_commands = set(["M48", "M49"])


def error(message):
    print("ERROR: " + message)

def debug(message):
    if (log_level < 1):
        print("DEBUG: " + message)

"""
A method to parse a line (block) of gcode into individual words
"""
def parse_gcode(block, linenum=-1) :
    #strip optional leading "/"
    block = re.sub("^/", "", block)
    #strip out all whitespace
    block = re.sub("\s","", block)
    #strip out inline comments, non-greedy
    block = re.sub("\\(.*?\\)", "", block)
    #capitalize all letters
    block = block.upper()
    #parse the block into individual words, not ignoring any unknown words and failing fast
        
    result = re.findall("[" + known_gcode_words + "]-?\d*\.?\d*", block)
    #check that each part of the string was matched, if not, raise an exception
    test_result = ""
    for word in result :
        test_result += word
    if (test_result != block):
        error("I was not able to parse a block of gcode.  When separating the following block using regex:")
        error(block)
        error("I got the following result:")
        error(test_result)
        raise Exception("I was not able to successfully parse the [" + block + "] block of gcode (input file line number: " + str(linenum) + ").")
    return result

'''
Given a block of gcode, returns an array of comments in that block 
'''
def extract_comments(block):
    #strip out inline comments, non-greedy
    result = re.findall("\\((.*?)\\)", block)
    return result

"""
Verify that the gcode is valid.
"""
def verify_gcode(block_array):
    # N words only in the first position
    # Check for line too long?
    # A line may have zero to four G words.
    # Two G words from the same modal group may not appear on the same line.
    # A line may have zero to four M words.
    # Two M words from the same modal group may not appear on the same line.
    # For all other legal letters, a line may have only one word beginning with that letter.

    return
    
def translate_file(input_filename, output_filename):
    debug("parsing " + input_filename)
    input_file = open(input_filename, "r")
    debug("sending output to " + output_filename)
    output_file = open(output_filename, "w")
    line_num = 0
    output_file.write("* * Anilam conversational format generated by anilampost.py at " + str(datetime.now()) + "\n")
    output_file.write("* * original file: " + input_filename + "\n")
    output_file.write("\n")
    for line in input_file:
        line_num += 1
        debug("Processing line number: " + str(line_num))
        debug(line)
        result = process_line(line, line_num)
        output_file.write(result)
            
    input_file.close()
    output_file.close()

"""
process an individual line
"""
def process_line(line, line_num):
    result = ""
    line_without_comments = re.sub("\\(.*?\\)", "", line)
    if (re.match("^\s*$", line)):
        debug("Processig as a line with only whitespace")
        result = "\n"
    elif (re.match("^\s*%\s*$", line_without_comments)):
        debug("Processig as a standalone % designating program start or end")
        result = "* * %\n"
    elif (re.match("^\s*$", line_without_comments)):
        #The line is comments and white space only
        #Extract the comments and print them
        debug("Processig as a line with comments and whitespace only")
        comments = extract_comments(line)
        for comment in comments:
            result = result + "* * " + comment + "\n"
    else:
        #The block is gcode and might contain comments
        debug("Processig as a line with gcode and optionally comments")
        #First, extract in-line comments
        if (log_level < 1):
            # in debug mode, write the original line in-line
            result = result + "* * " + line
        comments = extract_comments(line)
        for comment in comments:
            result = result + "* * inline comment: " + comment + "\n"
        #The, convert the line
        block = parse_gcode(line, line_num)
        conversational = convert_to_conversational(block, line, line_num)
        result = result + conversational + "\n"
        
    return result

"""
Given a gcode word, returns the command part of it
"""
def command_part(word):
    command_part = word[0]
    if (re.match("[" + known_gcode_words + "]",command_part)) :
        return command_part
    else:
        raise Exception("Uknown gcode command part: " + command_part + " in word [" + word + "]")

"""
Given a gcode word, returns the real_number part of it
"""
def real_part(word):
    real_part = word[1:]
    try:
        float(real_part)
        return real_part
    except ValueError:
        raise Exception("Uknown gcode real part: " + real_part + " in word [" + word + "]")

def to_four_digits(real):
    number = float(real)
    result = "%.4f" % number 
    return result
    
"""
converts an array of gcode words representing one gcode block
to Anilam conversational commands
"""
def convert_to_conversational(block_array, original_block, line_no=-1):
    global current_arc_coords_mode
    result = ""
    # preserve whitespace
    if (len(block_array) == 0):
        return ""
    
    # take the first element in the list
    first_word = block_array.pop(0)
    if (command_part(first_word) == "N"):
        #if it is a line number, ignore it
        first_word = block_array.pop(0)
    
    command = command_part(first_word)
    real = real_part(first_word)
    
    #Take a naive approach to parsing, just look at the first word, and 
    # the subsequent arguments to determine how to translate

    commands = {}
    remaining_command_string = ""
    for word in block_array:
        # use a set to determine what the remaining commands are
        remaining_command_string = remaining_command_string + command_part(word)      
        # also make a map of the remaining commands to allow easy string formatting
        commands[command_part(word)] = float(real_part(word))
        
    remaining_commands = set(remaining_command_string)
        
    #determine the command args and format it explicitly
    #error on cases not handled
    if (command == "G"):
        debug("Converting G command: " + original_block)
        if (real == "00" or real == "0"):
            if (remaining_commands == set("XYZF")):
                result = "Rapid      X {X:.4f} Y {Y:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XYZ")):
                result = "Rapid      X {X:.4f} Y {Y:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("XY")):
                result = "Rapid      X {X:.4f} Y {Y:.4f}".format(**commands)
            elif (remaining_commands == set("XYF")):
                result = "Rapid      X {X:.4f} Y {Y:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XZ")):
                result = "Rapid      X {X:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("XZF")):
                result = "Rapid      X {X:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("YZ")):
                result = "Rapid      Y {Y:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("YZF")):
                result = "Rapid      Y {Y:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("X")):
                result = "Rapid      X {X:.4f}".format(**commands)
            elif (remaining_commands == set("XF")):
                result = "Rapid      X {X:.4f} Feed {F:.4f}" .format(**commands)
            elif (remaining_commands == set("Y")):
                result = "Rapid      Y {Y:.4f}".format(**commands)
            elif (remaining_commands == set("YF")):
                result = "Rapid      Y {Y:.4f} Feed {F:.4f}" .format(**commands)
            elif (remaining_commands == set("Z")):
                result = "Rapid      Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("ZF")):
                result = "Rapid      Z {Z:.4f} Feed {F:.4f}" .format(**commands)
            else:
                error("unrecognized G00 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G00 command: " + original_block)
        elif (real == "01" or real == "1"):
            if (remaining_commands == set("XYZF")):
                result = "Line       X {X:.4f} Y {Y:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XYZ")):
                result = "Line       X {X:.4f} Y {Y:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("XY")):
                result = "Line       X {X:.4f} Y {Y:.4f}".format(**commands)
            elif (remaining_commands == set("XYF")):
                result = "Line       X {X:.4f} Y {Y:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XZ")):
                result = "Line       X {X:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("XZF")):
                result = "Line       X {X:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("YZ")):
                result = "Line       Y {Y:.4f} Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("YZF")):
                result = "Line       Y {Y:.4f} Z {Z:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("X")):
                result = "Line       X {X:.4f}".format(**commands)
            elif (remaining_commands == set("XF")):
                result = "Line       X {X:.4f} Feed {F:.4f}" .format(**commands)
            elif (remaining_commands == set("Y")):
                result = "Line       Y {Y:.4f}".format(**commands)
            elif (remaining_commands == set("YF")):
                result = "Line       Y {Y:.4f} Feed {F:.4f}" .format(**commands)
            elif (remaining_commands == set("Z")):
                result = "Line       Z {Z:.4f}".format(**commands)
            elif (remaining_commands == set("ZF")):
                result = "Line       Z {Z:.4f} Feed {F:.4f}" .format(**commands)
            else:
                error("unrecognized G01 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G01 command: " + original_block)
        elif (real == "02" or real == "2"):
            if (current_arc_coords_mode == "INC"):
            # convert the incremental coordinates to absolute to match what Anilam expects
                if ("I" in commands):
                    new_i = commands["I"] + commands["X"]
                    commands["I"] = new_i
                if ("J" in commands):
                    new_j = commands["J"] + commands["Y"]
                    commands["J"] = new_j
            if (remaining_commands == set("XYZIJF")):
                result = "Arc Cw     X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XYZIJ")):
                result = "Arc Cw     X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f}".format(**commands)
            else:
                error("unrecognized G02 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G02 command: " + original_block)
        elif (real == "03" or real == "3"):
            if (current_arc_coords_mode == "INC"):
            # convert the incremental coordinates to absolute to match what Anilam expects
                if ("I" in commands):
                    new_i = commands["I"] + commands["X"]
                    commands["I"] = new_i
                if ("J" in commands):
                    new_j = commands["J"] + commands["Y"]
                    commands["J"] = new_j
            if (remaining_commands == set("XYZIJF")):
                result = "Arc Ccw    X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f} Feed {F:.4f}".format(**commands)
            elif (remaining_commands == set("XYZIJ")):
                result = "Arc Ccw    X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f}".format(**commands)
            else:
                error("unrecognized G03 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G03 command: " + original_block)
        elif (real == "04" or real == "4" and remaining_commands == set("P")):
            #dwell
            result = "Dwell {P:.4f}".format(**commands)
        elif (real == "10" and remaining_commands == set("PRZ")):
            #tool definition
            raise Exception("tool handling not yet implemented")
        elif (real == "20" and remaining_commands == set("")):
            result = "Unit INCH"
        elif (real == "21" and remaining_commands == set("")):
            result = "Unit MM"
        elif (real == "90" and remaining_commands == set("")):
            #Absolute distance mode
            #The default
            result = "Dim Abs"
        elif (real == "91" and remaining_commands == set("")):
            #Incremental distance mode
            result = "Dim Inc"
        elif (real == "90.1" and remaining_commands == set("")):
            #Arc centers I,J,K are absolute
            #Use this setting to determine how to handle IJK
            current_arc_coords_mode = "ABS"
            result = result
        elif (real == "91.1" and remaining_commands == set("")):
            #The default
            #Arc centers I,J,K are relative to the arc's starting point
            #Use this setting to determine how to handle IJK
            current_arc_coords_mode = "INC"
            result = result
        else:
            error("unrecognized G command on line: " + str(line_no))
            error("original line:")
            error(original_block)
            raise Exception("unrecognized G command: " + original_block)
    elif (command == "M" and remaining_commands == set("")):
        debug("Converting M command")
        if (real in ("02", "2")):
            #End Program 
            result = "EndMain"
        elif (real in ("03", "3") and remaining_commands == set("")):
            #Turn spindle clockwise
            result = "MCode 3"
        elif (real in ("04", "4") and remaining_commands == set("")):
            #Turn spindle counter-clockwise
            result = "MCode 4"
        elif (real in ("05", "5") and remaining_commands == set("")):
            #Stop spindle
            result = "MCode 5"
        else:
            error("unrecognized M command on line: " + str(line_no))
            error("original line:")
            error(original_block)
            raise Exception("unrecognized M command: " + str(original_block))
    elif (command == "O" and remaining_commands == set("")):
        result = "* * " + command + real
    elif (command == "S" and remaining_commands == set("")):
        result = "RPM        {0:.4f}" .format(float(real))
    else:
        error("unrecognized command on line: " + str(line_no))
        error("original line:")
        error(original_block)
        raise Exception("unrecognized command: " + str(original_block))
    return result

def usage():
    print """
    A command-line program to convert gcode files into Anilam 
    conversational format.
    Usage:
    anilampost.py --input=<input_file_name> --output=<output_file_name> [--debug]
    
    Examples:
    anilampost.py --input=TEST.G --output=TEST.M
    
    if the debug option is specified, the original gcode is written out as comments
    in-line with the converted code.
    
    """

def main():
    global log_level
    
    debug("raw arguments")
    debug(sys.argv[1:])
    if (len(sys.argv) == 1):
        usage()
        sys.exit(2)
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ho:i:d", ["help", "output=", "input=","debug"])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output_file = None
    input_file = None
    for o, a in opts:
        if o in ("-d", "--debug"):
            log_level = 0
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-o", "--output"):
            output_file = a
        else:
            assert False, "unhandled option"
    
    if (input_file == None or output_file == None):
        print("You must supply both an input file and an output file")
        sys.exit(2)
    translate_file(input_file, output_file)

# when spawned via command line, execute the main method
if __name__ == "__main__":
    main()