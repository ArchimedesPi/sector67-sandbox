#summary A 3-axis CNC mill conversion from Anilam controls to EMC2

=Project Sheet Cake=
A three-axis CNC Mill Conversion from Anilam 1100 controls to EMC2

<wiki:toc max_depth="2" />

==Introduction==
In 2010, Sector67 (http://www.sector67.org) acquired two CNC mills, one with an Anilam 1100 control system and one with an Anilam 3300 control system.  At the time the CNC portion of the 3300 mill was non-functional but since then both of the mills have been brought into use and have generally been workhorses, with the 1100 mill being used primarily.  Although the Anilam 1100 system overall is somewhat dated, it has provided the needed functionality for many members to start down the path of CNC mastery.  We have worked to extend the existing system for our needs, writing a standalone Anilam post processor for converting abitrarily large gcode files in the most accurate way possible:

http://code.google.com/p/sector67-sandbox/wiki/AnilamPostProcessor

and a Python-based DNC program for running large programs via the serial port:

http://code.google.com/p/sector67-sandbox/wiki/AnilamPostProcessor

As we look to make best use of these mills in the hackerspace, we are hitting some of the limitations of the Anilam system.  In parallel other members have been developing our capability to perform 3D printing including building and tuning a couple of [http://wiki.makerbot.com/cupcake CupCake] CNC and RepRap-based systems and working on plastic extrusion print head issues.  Debugging some of these print issues led to a discussion around print head stability, and the potential to use our CNC mills as a 3D printing platform.

The Anilam control system is unfortunately not well suited for extension to additional axis and arbitrary machine and motion control.  However, the servos, servo controllers, spindle and other portions of the mill are rock solid, which led us to think of converting the mill to make use of more modern hardware and software that could more easily be adapted to the various sorts of arbitary precision machine control needs that might come up at a hackerspace.  Specifically, of course, decorating a sheet cake.

So, in the spirit of the CupCake CNC, which is named for the approximate size of artifact it can create, we have dubbed our CNC mill conversion project "Project Sheet Cake".

==Choosing control hardware and software==
When looking at possible choices for updated software and hardware, two software choices in particular were contenders.  [http://linuxcnc.org/ EMC2] and Mach3 both have large groups of adherents and active development work ongoing.  However, for control of our servo system, EMC2 makes more sense as Mach3, which runs as an application on top of Windows, is geared primarily toward bit-blasting stepper systems.  If we wanted to control the servos via Mach3, we'd need a hardware-based solution to manage the servo encoder feedback loop.  This tends to be more expensive hardware-wise.

EMC2, on the other hand, runs on top of Linux with a real-time kernel and can thus handle the encoder feedback in software on the PC.  In addition, EMC2 is open source software which in many ways better fits the hackerspace ethic.

With respect to the interface hardware, it is very common with both Mach3 and ECM2 to use a parallel port to drive no-feedback stepper systems.  However, with our drives we needed the ability to read digital encoder input from three axis and output analog +/-10V signals to drive the servo amplifiers.  A couple of folks had already done conversions of the scale we were considering using hardware from Mesa Electronics (http://mesanet.com).  Although they offer no discount to hackerspaces, support for their hardware in EMC2 is very mature, and their costs in any case are on the lower side of the servo-capable interface hardware.  The fact that their PCI cards are arbitrary I/O cards based on Xilinx FPGA will hopefully give us as much flexibility as we could want.

Specifically, we have chosen the following boards from [http://mesanet.com Mesa]:

  * A [http://mesanet.com/pdf/parallel/5i23man.pdf 5I23] FPGA based PCI  Anything I/O card.  This card will go in the PC, and 50 pin ribbon cables will provide signals to the daughter cards.  Currently $229 in small quantities.

  * A [http://mesanet.com/pdf/motion/7i33man.pdf 7i33TA] quad analog servo interface daughter card.  This card will be wired to provide the servo amps with the appropriate +/-10V input signals, and take the encoder signals in and clean them up for EMC2.  Currently $79 in small quantities.

  * A [http://mesanet.com/pdf/parallel/7i37man.pdf 7i37TA] isolated I/O daughter card.  This card will be used to provide isolated output from EMC2 for the servo enable and servo reset signals (amongst other things), and to provide input of some machine state to EMC2.  Currently $79 in small quantities.

==Basic architecture==
This diagram shows the basic high-level architecture of the system:

http://sector67-sandbox.googlecode.com/svn/trunk/ProjectSheetCake/docs/images/basic-architecture.png

The original svg source for this image is under revision control in the sector 67 sandbox source repository.

=Understanding the new interface components=

==The integration board==
The integration board is a custom-made board designed to hold the Mesa daughter boards for interfacing with the existing mill's 0.2" and DB9 plugs providing power, estop, limit, rotary encoder in and servo amp out in the servo amp box. It is designed to be a plug and play replacement for the Anilam S1100 distribution board in the large chassis that holds the servo amps. 

We've taken great pains to design this board such that if we ever wanted to restore the original Anilam functioanlity, that could easily be done.

The base of this board is a piece of (TODO: get gauge) 7"x12" aluminum sheet, with a 1/2" strip along the 12" edge folded at 90 degrees to give stiffness and provide a way to secure the board to the chassis. 

On top of this sheet we've attached the Mesa daughter boards, serial connectors and through hole prototype perf boards for securing the connector headers and other components with 3/8" standoffs.

The right hand side of this board primarily handles servo drive I/O, with the encoder input coming from the drives on the DB9 connectors with the signals as described in the encoder section below.

There were several special considerations when designing and implementing this board.  

  * Since we wanted to make the board plug-compatible with the exsiting mill, we needed to source 0.2" two-layer header connectors.  The appropriate headers are listed in the parts list
  * Most serial connectors are designed as through-hold board components or cable ends.  In addition, prototype perf boards for serial connectors are somewhat hard to come by.  So, in order to be able to attach the serial connectors securely to the aluminum sheet, we used female DB9 ribbon connectors and used standoffs to attach the DB9 connectors directly to the board.  We then stripped and tinned the individual wires from the ribbon cable so that they could be directly terminated in the screw terminals of the 7i33TA servo controller card.
  * One of the standoffs was in electrical contact with one of the solder traces on the perf board, so a plastic standoff was improvised from a piece of plastic tube.


TODO: finish parts list, pictures, component layout and schematic. 


Integration board parts list
|| *Part* || *Price per* || *Quantity* || *Description* || *Vendor* || *Part Number* ||
|| 2x8 0.2" terminal plug || $4.85 || 2 || A through-hole soldered terminal plug with two rows of 8 pins. || Digikey || A98151-ND ||
|| 2x6 0.2" terminal plug || $3.65 || 5|| A through-hole soldered terminal plug with two rows of 6 pins. || Digikey || A98150-ND ||
|| DB9 female ribbon connector || $$ || 4 || A female DB9 plug with ribbon cable connector || Digikey || ||
|| 3/8" Standoffs  || $$ || 40 || 3/8" male/female #4-40 brass standoffs for attaching the daughter boards and perf boards to the aluminum sheet || Digikey || ||
|| 1/4" Standoffs || $$ || 10 || 1/4" male/female #4-40 standoffs for attaching the DB9 connectors to the 3/8" standoffs || Digikey || ||
|| #4-40 nuts || $$ || 40 || #4-40 nuts for connecting the standoffs to the aluminum sheet || Digikey || ||
|| #4-40 screws || $$ || 40 || #4-40 nuts for connecting the boards to the standoffs || Digikey || ||
|| 9-wire ribbon cable || N/A || 4 || 9-wire 0.05" pitch ribbon cable for the DB9 plugs.  Approximately 10" long for the longest run.  I split 9-wire ribbons off of a salvaged floppy disk cable || N/A || N/A ||
|| Connecting wire || N/A || ~5' || Various lengths of 22 gauge stranded wire for connecting the through-hole perf board components to the daughter boards and for connecting parts on the perf board.  I used wire salvaged from cables.  || N/A || N/A ||
|| 2"x4" Prototype perf board || $6.26 || 4 || 0.1" hole spacing prototype perf board with copper on one side. || Digikey || V2025-ND ||
|| Red LEDs || $0.48 || 10 || Red light-emitting diodes for on-board indicators || Digikey || 511-1256-1-ND ||
|| Green LEDs || $0.52 || 10 || Green light-emitting diodes for on-board indicators || Digikey || 511-1254-1-ND ||
|| 2.2k 1/2 watt LED pull-up resistors || $0.093 || 20 || Pull-up resistors for LEDs on the 24V circuits || Digikey || 2.2KH-ND ||


TODO: full schematic diagram here

==The PCI I/O card==

=Understanding the current mill and controller=
==The servo encoders==
Since servo motors, unlike steppers, are not able to be directly controlled to move a specific distance via input only, some feedback is necessary in order to be able to accurately position them.  Our servo motors have two types of feedback, an analog velocity, which is fed back to the servo amplifiers directly, and a incremental (quatrature) rotary encoder.  The rotary encoder is read by EMC2 and used to accurately determine how far the motors have moved.  There are several types of rotary encoders, and ours, as is typical on servo motors, are incremental rotary encoders.  You can learn more about these at the following links:

http://en.wikipedia.org/wiki/Rotary_encoder#Incremental_rotary_encoder

http://prototalk.net/forums/showthread.php?t=78

But the basic idea is that there are two encoder signals, A and B, which are enabled 90 degrees out of phase from one another.  These signals pulse high and low as the shaft is rotated, and so accurate sensing and counting of the pulses relative to one another allows you to keep track of how far the shaft has turned and in which direction.  There is a third encoder signal, X, which pulses high once per full rotation of the shaft.  In addition to these three signals, the encoders on our motors require +5V and a ground, so there are a total of 5 wires for each servo motor: A, B, X, +5V, GND.  These wires come from the servo motor into the round connector in the case (documented elsewhere) and from there into a DB9 connector with the following pinout, as looking into the female DB9 connector:

TODO: servo encoder DB9 pinout.

The 7i33 can be configured via jumpers for two sorts of encoder input, TTL or RS-422 ("differential").  The encoder signal on our motors are 0V to +5V TTL, so the 7i33 jumpers were left in the default TTL configuration.  The alternative (RS-422) uses both positive and negative voltage and is good for sending signals longer distances.  We take the TTL encoder signals and wire them to the The 7i33 servo controller daughterboard, which cleans them up for the PCI card and ultimately EMC2. The 7i33 daughterboard also provides ground and +5V to the encoders.

While the encoder feedback primarily allows for accurate positioning, it does have an additional benefit that the controller can determine when the machine is not accurately following the instructions given.  This sort of error is called "following error" and when EMC2 detects following error it will put the machine into an estop state.

While the encoders provide information about the shaft turning, they do not specify an absolute distance or angle turned.  In order for EMC2 to be able to accurately position the system, it needs to be able to translate rotary encoder pulses into a linear distance moved.  This depends on both the pitch of the mill lead screws and the number of pluses per turn of the encoders.  In our case we needed to determine this translation experimentally:

TODO: Document we configured EMC2 to know how far a specific pulse moved the motors.

Direct linear encoders are also sometimes used.  These measure the movement of the table itself via pulses, but our mill does not have them.  Linear encoders are helpful in that you can directly measure and compensate for backlash in lead screws, but they are tend to be more complex and are not cheap.

==The servo enable/estop circuit==

The server enable circuit is basically a set of four relays that are used to provide 120VAC to the servo power supply and power to the spindle relay.  Most of the heavy lifting of the servo enable circuit is done on a separate circuit board ("Anilam PC 801") that contains the physical relays and connects to out integration board via an 8 pin header.

Although it would be possible to run the estop and limit functions completely in software with emc2, we are choosing to preserve the existing hardware solution, with machine state being read by emc2.

Since our mill does not have separate limit/home switches, this effectively means that we will not be able automatically home to a machine absolute zero.  However, since nearly all of our milling is currently done relative to a local zero this will hopefully not be a severe limit.  With so many different users using the mill, and potentially even working on the emc2 software, a hardware hard limit seemed like the more prudent decision.  Separate home switches could be added in the future if that feature is needed.

Each axis has a set of limit switches that are wired in series, along with an DPST (double pole single throw) estop button.  These switches are all normally closed, and provide part of the 24V ground circuit for the bottom two (as viewed in the box) relays on the relay board.

The relays are:

K4: Top relay, enabled state represents servo enable, 
Ground path controlled by the PC "servo enable" flag.  
When energized helps complete the ground path for K1 and K3.

K1: Middle relay, active output facilitates the latching circuit by providing the ground circuit to itself
Ground path controlled by (in series):

  * The limit switches
  * The estop button
  * The K1 relay being energized and/or the SERVO_RESET path enabled.  
  * The K4 relay being energized

When energized, helps completes the ground path for K1 and K3
The closed when non-energized portion of this relay controlls the "servo off" signal to the PC.

SERVO_RESET is meant to be temporarily engergized to allow the latch state to be set up.  It should then be disabled so that if the ground path is broken via the limit switches, estop, etc., K1 will be de-energized. 

K3: Bottom relay
Ground path is the same as K1
When energized drives the K2 solid state relay on the back side of the board to enable the spindle relay and provide 120VAC to the servo amp power supply.


Input signals:

SERVO_OFF

X_LIMIT

Y_LIMIT

Z_LIMIT

ALL_LIMITS_OK

E_STOP_OK

SERVO_RESET_IN

MANUAL?

Not all of these signals will need to be fed to EMC2.  Some may just be represented with LEDs on the integration board.
 
Signals from the PC:

SERVO_ENABLE: When active specifies that the servos should be enabled

SERVO_RESET: When momentarily active allows ground to flow past the K1 relay to allow K1 to energize and set up the latched circuit.

E_STOP: A part of the estop circuit.  Needs to be active to allow the servos to energize.  Allows for a software estop.


The signals from the PC will need to be mapped to pins within EMC2.  Normally, EMC2 manages a "MACHINE_ON" and TODO: get signal..., and these can be mapped in the following way:

A separate SERVO_RESET will need to be created and managed via the EMC2 software.  This could be done via a normally-open hardware button as well (or even making use of the existing ANILAM console servo reset button), but managing it in software seems to be the most straightforward method of handling this signal.  When this signal is momentarily enabled, it allows the latching circuit to be set up.

=EMC2=

==Choosing and validating a PC==
Because EMC2 runs using a real time Linux kernel, it has specific hardware requirements.  Most notably, the system needs to be able to respond to low-level requests in a specific (low) amount of time in order for EMC2 to be able to perform critical motion-control hardware functions such as counting encoder pulses and stepping stepper motors.

Because of this, functions such as power-saving and on-board graphics tend to not work well on real-time systems.  EMC2 provides a latency-test tool that can be used to evaluate your system to see if is acceptable for use as an EMC2 system:

http://wiki.linuxcnc.org/emcinfo.pl?Latency-Test

When running this against the default configuration of our candidate PC:

TODO: document PC configuration, manufacturer, BIOS version, etc.

we saw numbers that were out of range for use as an EMC2 host:

{{{TODO: get numbers}}}

We've tried the following:
TODO: document what was tried



==Installing EMC2==
EMC2 is fairly easy to install.  We burned a copy of the live cd:

http://linuxcnc.org/index.php?option=com_content&task=view&id=21&Itemid=4&lang=en

configured the PC's BIOS to boot from the CD first, rebooted and chose the installation option.  There were a few simple choices to be made, the most notable of which were the locale, host name, user name and password, and we chose to have the user automatically logged on at startup.

After the installation process finished successfully, we removed the live CD, reconfigured the BIOS to boot from the hard drive, and restarted to a functional Ubuntu system with EMC2 installed.  This was an astonishingly simple alternative to what I thought might be quite daunting (getting the real-time kernel extensions working, etc.).

After install, there were options to start EMC2, view the documentation or run of several utilities.

One minor Linux customization was to configure the screen saver not to lock the PC, and to have it only come on after 30 minutes.  

==Configuring EMC2==
Once EMC2 was installed, we started it via Applications=>CNC->EMC2.  It prompted for a configuration, and we chose "hm2-server -> 5i23" as that matched our configuration.

From there, basically no additional work was needed to have things basically work.  The 7i23, server control daughterboard was hooked up to the first of three 50 pin outputs from the 5i23, and after confirming this is where the configuration expected it by viewing the pinouts via dmesg, we hooked up the encoders and they worked properly the first time.

After that, we hooked up the Z-axis servo amp and it also worked the first time, with intermittent following errors.  We then hooked up the X and Y axes, but the X axis would attempt to move 

In any case, though, EMC2 was basically functional for moving servos and reading encoders out of the box with the appropriate example configuration.  VERY NICE!


==Tuning EMC2==

=Extending=

==Integrating additional control capability==

=Build log=
Check out the SheetCakeBuildLog.