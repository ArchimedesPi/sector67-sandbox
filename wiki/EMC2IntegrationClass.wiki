#summary An outline of the content of the Sector67 EMC2 Machine Integrator's class

=Implementing CNC motion control with EMC2=
If you have a working mill or are planning to build one and are interested in controlling it via computer.  This class will prepare attendees to convert or build the computer control system for a mill or other machine with the Linux-based open source EMC2 software suite.  The class will cover choosing and configuring the software, PC, I/O interface components, electronic interface hardware, motors and motor controllers needed to move a machine.  The actual mechanics of machine building (axes, lead screws, etc.) are not covered in this class.

<wiki:toc max_depth="3" />

= Introduction to machine control concepts =
== Big picture goals ==
There are many different reasons for wanting to implement computerized motion control, including mills, lathes, plastic extrusion, plasma or laser cutting and other applications unrelated to manufacturing.  In all of these cases, we want to be able to move machines accurately, efficiently and reliably with the minimum hardware and software cost required to get the job done.  EMC2 as part of an overall motion control solution can help fulfill those goals.

== Brief gcode primer ==
To illustrate some of the challenges of motion control, we'll consider an extremely simple snippet of gcode to rapidly move the machine to the home position and then move one unit in the X direction at a feed speed of 100 units per minute:

{{{
G00 X0 Y0 Z0
G01 X1 Y0 Z0 F100
}}}

== Mass, momentum, acceleration and velocity ==
Assuming the machine is already at the home position, in an ideal world the machine would immediately start to travel at the feed rate, reach the end of the move and immediately stop.  In the real world of course, the table, motors and other moving machine components have mass and momentum and so the machine needs to accelerate to reach the desired velocity, and then decelerate to not overshoot at the end of motion.  Because of these real-world concerns, even seemingly simple machine motion operations present quite sophisticated motion planning challenges.

As a result, high-end motion control systems have historically incorporated relatively expensive dedicated motion planning hardware.  As the capabilities of general-purpose commodity PC hardware long ago surpassed what is needed for motion planning, it has become possible to use a PC instead of dedicated motion planning hardware, with one important caveat.  The software controlling the hardware must be capable of controlling the motors and (in the case of closed-loop control systems) reading motion feedback in "real time", or with a certain level of response time guaranteed.

Most modern operating systems are shared, interrupt-driven and function with ever-increasing abstraction away from physical hardware and cannot guarantee low response time needed for real-time operations.  However, there are several commercial real-time operating systems, and most important for EMC2, at least two options for real-time extensions to the Linux kernel that allow it to provide real-time capability.  EMC in particular makes use of the RTAI extensions, and these will be covered a bit more later.

== Understanding types of feedback and encoders ==

  * Stepper and servo systems compare and contrast
  * PID tuning concepts introduced

== Simplified block diagram of a typical motion control system =

http://sector67-sandbox.googlecode.com/svn/trunk/ProjectSheetCake/docs/images/motion-control-block-diagram.png

  * User interface
  * Programmable motion controller
  * Interface hardware
  * Power supply
  * Motor controllers/amplifiers
  * Motors
  * Encoders
  * Encoder feedback

== Machine shop tour ==
Time to put see the simplified block diagram in practice in a few different configurations.  A tour of the Sector 67 machine shop will allow us to see at least three different types of systems that we can map onto our basic block diagram.

=== Proprietary Anilam control system ===
The Anilam 3300 system is a sophisticated 3-axis closed-loop commercial servo system.  The user interface runs under DOS on a dedicated "PC on a card" industrial PC system.  The programmable motion control board is an ISA card.  Both of these are in the upper cabinet.  The interface hardware, which for this system also controls estop and limit functions and can completely disable servo amp power, is in the lower cabinet, along with the servo amplifiers and amplifier power supply.

=== EMC2 converted control system ===
Many more details of our EMC2 converted system can be found at [ProjectSheetCake].  The User interface and programmable motion controller are EMC2 on a Linux real-time kernel.  The interface hardware is a Mesa PCI I/O board with daughterboards for servo control (cleaning up encoder input and performing frequency to voltage conversion for the servo control signals) and optically isolated I/O.  The Anilam estop and limit functions were preserved and are interfaced to EMC2 via isolated I/O.

=== Small mill stepper control system ===
Joe's mini mill is an open-loop servo control system using Mach3 on a Windows PC to control stepper amps.  This system performs motion planning in software and uses the PC's parallel port for interfacing to the Xylotex stepper motor controllers.

=== A Makerbot ===
The Makerbot is an open-loop stepper-based system.  It uses a PC for the user interface, and an Arduino for the programmable motion controller.  GCode commands are sent to the Arduino via a serial interface, and the relatively low-power Arduino performs linear interpolation of any arc commands sent.  


= Introduction to EMC2 =
== Introduction ==
EMC stands for "Enhanced Machine Control".  It is a software system for computer control of machine tools such as milling machines and lathes.  EMC is free software with open source code. Current versions of EMC are entirely licensed under the GNU General Public License and Lesser GNU General Public License (GPL and LGPL).  It is a very mature motion control platform, capable of control of up to 9 axes.

== Background and history ==
EMC was originally developed by the National Institutes of Standards and Technology
 
== Community and support ==
EMC2 has a thriving community and excellent support is available from several sources.  There is an IRC channel, emc-users (and developer) mailing lists, and online forums.

== Basic architecture ==
== Real-time considerations ==
=== Base thread ===
=== Servo thread ===
  * Comparison with Mach3
  * Choosing and testing PC hardware for EMC2
  * Choosing interface hardware for EMC2
    * Parallel ports
    * Dedicated I/O boards
  * The EMC2 live CD
  * Updating the software via the EMC2 buildbot
  * Running EMC2 in simulation mode for development and testing

==Exercise 1: installing a virtual EMC2 instance==
The first exercise is to create a virtual EMC2 sandbox for yourself.  This sandbox will have multiple uses, including familiarizing yourself with EMC2 configuration, practice using various EMC2 GUIs, practice configuration editing and things like classic ladder development.

Please reference [InstallEMC2InAVirtualBox] for the detailed exercise.

=EMC2 configuration=
  * Keeping your software configuration under revision control
  * Using pncconf for generating your configuration
  * The HAL files
  * Hardware drivers
  * The ini file
  * User interface components
  * Axis UI

=Concerns when interfacing the hardware electronics=
  * Failure modes
  * Mains isolation
  * Electrical noise
  * Ground loops
  * Optical isolation
  * Physical robustness
  * Heat dissipation
  * Emergency stops
  * Machine limits

=Integrating the hardware electronics=
  * Review of the 1100 mill conversion integration

=Debugging EMC2=
  * HAL meter
  * HAL scope
  * HAL command lines

=Moving the machine under feedback control=
  * PID tuning applied

=Customizing the software futher=
  * Classicladder-based programs
  * PyVCP UI elements
  * Custom gcode integration
  * Machine communication to outside sources (IRC, X)?
  * Displaying custom messages in axis
  
=Customizing the hardware further=
  * Various 4th axis configuration scenarios
  * Probe input for touch off and automated sensing
  * Automated tool changers
  * Coordinated spindle moves (tapping, etc.)
  * Different spindle heads (plastic extrusion, frosting extrusion, tangential knife, etc.)